# Автоматическое тестирование

Основано на https://ru.hexlet.io/courses/js-testing/

## 
функциональные тесты проверяют, что код выполняет свою прямую задачу с точки зрения пользователей программы

По степени изолированности тестируемых частей кода функциональные тесты принято делить на:

- Модульные
- Интеграционные
- Системные

Самые простые и наименее эффективные тесты — **модульные**. Они проверяют работоспособность конкретных программных модулей, например, функций. Такие тесты проще всего писать, 


но они не способны помочь проверить, что модули работают вместе.За это уже отвечают **интеграционные** тесты.

Наиболее сложные и максимально эффективные — **системные** тесты. В случае сайтов — это тестирование через браузер

## Автоматические тесты

Всё, что требуется от автоматических тестов — повторить проверки, которые мы выполняли, делая ручное тестирование. Для этого достаточно старого доброго if и исключений.

Исключения создаются такой конструкцией:
```js
// Дословно: выбросить новую ошибку
// Исключения бросают
throw new Error('описание исключения');
// Код, следующий за этим выражением, не выполнится, а сам скрипт завершится с ошибкой
console.log('nothing');
```

Пример теста:
```js
if (capitalize('hello') !== 'Hello') { // Если результат функции не равен ожидаемому значению
  // Выбрасываем исключение и завершаем выполнение теста
  throw new Error('Функция работает неверно!');
}
```

В коде тесты, как правило, складывают в специальную директорию в корне проекта. Обычно она называется tests, хотя встречаются и другие варианты:
```
src/
├── bin
│   └── hexlet.js
├── half.js
└── index.js
tests/
└── half.test.js
```

Теперь при любых изменениях, затрагивающих эту функцию, важно не забывать запускать тесты:
```
node tests/capitalize.test.js
# Если все хорошо, код молча выполнится.
# Если есть ошибка, то будет выведено сообщение об ошибке.
```

Хорошие тесты ничего не знают про внутреннее устройство проверяемого кода. Это делает их более универсальными и надёжными.

## пограничные случаи. 
Это ситуации, в которых код может повести себя по-особенному:

- Работа с пустой строкой
- Обработка null
- Деление на ноль (в большинстве языков вызывает ошибку)
- Специфические ситуации для конкретных алгоритмов

Особняком стоят ошибки типов входных данных.

Ответственность за передачу правильных данных в функцию capitalize() лежит **не на ней, а на коде, который вызывает эту функцию**. И если он хорошо протестирован, то подобная ошибка либо обнаружится, либо вообще не возникнет.

```js
// Содержимое теста:

if (capitalize('hello') !== 'Hello') {
  throw new Error('Функция работает неверно!');
}

if (capitalize('') !== '') {
  throw new Error('Функция работает неверно!');
}

console.log('Все тесты пройдены!');

// Запуск:

node tests/capitalize.test.js

```

Node.js поставляется с модулем assert, в котором есть несколько функций, упрощающих написание утверждений:

```js
// Такой необычный импорт связан с тем,
// что assert, экспортируемый по умолчанию, считается устаревшим
// Правильно использовать strict
import { strict as assert } from 'assert';
```

В самом простом случае assert используется как функция, которая проверяет истинность переданного значения. Другими словами, assert(true) означает, что всё хорошо, а assert(false) говорит об ошибке

```js
// Первый параметр actual – то, что пришло
// Второй параметр expected – то, что ожидает тест
// Правильный порядок аргументов имеет большое значение при анализе ошибки
assert.equal(capitalize('hello'), 'Hello');
```

Однако, будьте осторожны. Функция strictEqual(actual, expected) проверяет равенство по ссылке. То есть два разных объекта, имеющих одинаковое содержание, рассматриваются как не эквивалентные

## Assert

isntallation:
https://nodejs.org/api/assert.html


```js
import { strict as assert } from 'node:assert';
// import { strict as assert } from 'assert';

// обычное сравнение
assert.strictEqual(isPrime(3), true)

// для сравнения структур данных (тема равенства массивов)
assert.deepStrictEqual(actual, expected);

```

## power-assert
Более полезный инструмент

```
// docs
https://github.com/power-assert-js/power-assert#be-sure-to-transform-test-code

// setup
npm install --save-dev mocha power-assert intelli-espower-loader
```

```js
import assert from 'power-assert';
```

## Supressor

Как работают тесты Хекслета и Supressor

https://help.hexlet.io/ru/articles/111145-kak-my-testiruem-testy-utilita-suppressor

Пример функции теста

```js
import _ from 'lodash';

const functions = {
  right1: (items, value, fromIndex = 0) => items.indexOf(value, fromIndex),


  wrong1: (items, value, fromIndex = 1) => items.indexOf(value, fromIndex),


  wrong2: (items, value, fromIndex) => {
    const index = items.indexOf(value, fromIndex);
    return index === -1 ? 0 : index;
  },
  wrong3: (items, value) => items.indexOf(value),
  wrong4: (items, value) => _.lastIndexOf(items, value),
};

export default () => {
  const name = process.env.FUNCTION_VERSION || 'right1';
  return functions[name];
};
```

Примеры решений задач

```js

// 04 power-assert

// 'right'
// right1: (items, value, fromIndex = 0) => items.indexOf(value, fromIndex)
assert(indexOf(tests[0], 2) === _.indexOf(tests[0], 2)); // equality is true

// 'wrong1'
// wrong1: (items, value, fromIndex = 1) => items.indexOf(value, fromIndex),

// цель wrong1 - проверить, что при замене аргументе индекса на другое
// значение (а именно, если в функцию подставить поиск с 1 индекса, то 
// функция продолжит работать корректно
assert(indexOf([1, 2, 1, 2], 1) === 0);


// "wrong2"
// wrong2: (items, value, fromIndex) => {
//   const index = items.indexOf(value, fromIndex);
//   return index === -1 ? 0 : index;
// },
// цель - проверить случай, когда элемента нет в массиве
assert(indexOf([1, 2, 1, 2, 4, 10, 41, 666, 999], 322) === -1);

// 'wrong3' - проверяет кейс, если стартовать не с первого вхождения элемента
// wrong3: (items, value) => items.indexOf(value)
assert(indexOf([999, 1, 2, 1, 2, 4, 10, 41, 666, 999], 2, 3)  === 4);

// 'wrong4' - проверяет кейс нахождения элемента по последнему индексу
// wrong4: (items, value) => _.lastIndexOf(items, value),
assert(indexOf([1, 8, 9, 3, 9, 43], 43) === 5);
```

## Jest библиотека
https://ru.hexlet.io/courses/js-testing/lessons/jest/theory_unit 

```bash
# установка пакета
npm init

# В директории с проектом
npm i --save-dev jest

# "type": "module" -- add in package.json

# Создание файла в каталоге проекта 
./__tests__/index.test.js


# запуск теста с помощью jest
# Jest поддерживает ECMAScript модули в экспериментальном режиме
# Чтобы активировать поддержку модулей в тестах,
# нужно запускать тесты с переменной окружения NODE_OPTIONS

NODE_OPTIONS=--experimental-vm-modules npx jest
```

Для тестов Jest предоставляет две глобальные функции: test и expect. Они доступны без какого-либо импорта, так как Jest делает их глобальными функциями.

Функция **test** нужна для описания конкретного теста и его проверок. Самих тестовых функций может быть любое количество. Первым параметром эта функция принимает произвольную строчку, которая должна описывать сам тест. Эта строчка потом отображается на экране во время запуска тестов для упрощения отладки.

Второй параметр — функция, внутри которой описан проверочный код. Обратите внимание на то, что этот код не выполняется сразу. Функция test добавляет его внутрь Jest, который уже решает, как и когда запускать тесты. Это позволяет проводить различные оптимизации, например, выполнять тесты параллельно.

Jest использует "матчеры" (matchers). Это утверждения, имеющие особую структуру, напоминающую обращение к объекту. Общий принцип работы матчеров такой:

Вызывается функция expect(), куда передаётся актуальное (фактическое) значение.
На результате, возвращаемом функцией expect(), вызывается подходящий матчер, например, toEqual.

```js
test('reverse', () => {
  expect(reverse('hello')).toEqual('olleh');
  expect(reverse('')).toEqual('');
});

// Ожидается, что результат выражения reverse('hello') равен 'olleh'
expect(reverse('hello')).toEqual('olleh');
```
