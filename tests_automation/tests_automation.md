# Автоматическое тестирование

Основано на https://ru.hexlet.io/courses/js-testing/

## 
функциональные тесты проверяют, что код выполняет свою прямую задачу с точки зрения пользователей программы

По степени изолированности тестируемых частей кода функциональные тесты принято делить на:

- Модульные
- Интеграционные
- Системные

Самые простые и наименее эффективные тесты — **модульные**. Они проверяют работоспособность конкретных программных модулей, например, функций. Такие тесты проще всего писать, 


но они не способны помочь проверить, что модули работают вместе.За это уже отвечают **интеграционные** тесты.

Наиболее сложные и максимально эффективные — **системные** тесты. В случае сайтов — это тестирование через браузер

## Автоматические тесты

Всё, что требуется от автоматических тестов — повторить проверки, которые мы выполняли, делая ручное тестирование. Для этого достаточно старого доброго if и исключений.

Исключения создаются такой конструкцией:
```js
// Дословно: выбросить новую ошибку
// Исключения бросают
throw new Error('описание исключения');
// Код, следующий за этим выражением, не выполнится, а сам скрипт завершится с ошибкой
console.log('nothing');
```

Пример теста:
```js
if (capitalize('hello') !== 'Hello') { // Если результат функции не равен ожидаемому значению
  // Выбрасываем исключение и завершаем выполнение теста
  throw new Error('Функция работает неверно!');
}
```

В коде тесты, как правило, складывают в специальную директорию в корне проекта. Обычно она называется tests, хотя встречаются и другие варианты:
```
src/
├── bin
│   └── hexlet.js
├── half.js
└── index.js
tests/
└── half.test.js
```

Теперь при любых изменениях, затрагивающих эту функцию, важно не забывать запускать тесты:
```
node tests/capitalize.test.js
# Если все хорошо, код молча выполнится.
# Если есть ошибка, то будет выведено сообщение об ошибке.
```

Хорошие тесты ничего не знают про внутреннее устройство проверяемого кода. Это делает их более универсальными и надёжными.

## пограничные случаи. 
Это ситуации, в которых код может повести себя по-особенному:

- Работа с пустой строкой
- Обработка null
- Деление на ноль (в большинстве языков вызывает ошибку)
- Специфические ситуации для конкретных алгоритмов

Особняком стоят ошибки типов входных данных.

Ответственность за передачу правильных данных в функцию capitalize() лежит **не на ней, а на коде, который вызывает эту функцию**. И если он хорошо протестирован, то подобная ошибка либо обнаружится, либо вообще не возникнет.

```js
// Содержимое теста:

if (capitalize('hello') !== 'Hello') {
  throw new Error('Функция работает неверно!');
}

if (capitalize('') !== '') {
  throw new Error('Функция работает неверно!');
}

console.log('Все тесты пройдены!');

// Запуск:

node tests/capitalize.test.js

```

Node.js поставляется с модулем assert, в котором есть несколько функций, упрощающих написание утверждений:

```js
// Такой необычный импорт связан с тем,
// что assert, экспортируемый по умолчанию, считается устаревшим
// Правильно использовать strict
import { strict as assert } from 'assert';
```

В самом простом случае assert используется как функция, которая проверяет истинность переданного значения. Другими словами, assert(true) означает, что всё хорошо, а assert(false) говорит об ошибке

```js
// Первый параметр actual – то, что пришло
// Второй параметр expected – то, что ожидает тест
// Правильный порядок аргументов имеет большое значение при анализе ошибки
assert.equal(capitalize('hello'), 'Hello');
```

Однако, будьте осторожны. Функция strictEqual(actual, expected) проверяет равенство по ссылке. То есть два разных объекта, имеющих одинаковое содержание, рассматриваются как не эквивалентные

## Assert

isntallation:
https://nodejs.org/api/assert.html


```js
import { strict as assert } from 'node:assert';
// import { strict as assert } from 'assert';

// обычное сравнение
assert.strictEqual(isPrime(3), true)

// для сравнения структур данных (тема равенства массивов)
assert.deepStrictEqual(actual, expected);

```

## power-assert
Более полезный инструмент

```
// docs
https://github.com/power-assert-js/power-assert#be-sure-to-transform-test-code

// setup
npm install --save-dev mocha power-assert intelli-espower-loader
```

```js
import assert from 'power-assert';
```

## Supressor

Как работают тесты Хекслета и Supressor

https://help.hexlet.io/ru/articles/111145-kak-my-testiruem-testy-utilita-suppressor

Пример функции теста

```js
import _ from 'lodash';

const functions = {
  right1: (items, value, fromIndex = 0) => items.indexOf(value, fromIndex),


  wrong1: (items, value, fromIndex = 1) => items.indexOf(value, fromIndex),


  wrong2: (items, value, fromIndex) => {
    const index = items.indexOf(value, fromIndex);
    return index === -1 ? 0 : index;
  },
  wrong3: (items, value) => items.indexOf(value),
  wrong4: (items, value) => _.lastIndexOf(items, value),
};

export default () => {
  const name = process.env.FUNCTION_VERSION || 'right1';
  return functions[name];
};
```

Примеры решений задач

```js

// 04 power-assert

// 'right'
// right1: (items, value, fromIndex = 0) => items.indexOf(value, fromIndex)
assert(indexOf(tests[0], 2) === _.indexOf(tests[0], 2)); // equality is true

// 'wrong1'
// wrong1: (items, value, fromIndex = 1) => items.indexOf(value, fromIndex),

// цель wrong1 - проверить, что при замене аргументе индекса на другое
// значение (а именно, если в функцию подставить поиск с 1 индекса, то 
// функция продолжит работать корректно
assert(indexOf([1, 2, 1, 2], 1) === 0);


// "wrong2"
// wrong2: (items, value, fromIndex) => {
//   const index = items.indexOf(value, fromIndex);
//   return index === -1 ? 0 : index;
// },
// цель - проверить случай, когда элемента нет в массиве
assert(indexOf([1, 2, 1, 2, 4, 10, 41, 666, 999], 322) === -1);

// 'wrong3' - проверяет кейс, если стартовать не с первого вхождения элемента
// wrong3: (items, value) => items.indexOf(value)
assert(indexOf([999, 1, 2, 1, 2, 4, 10, 41, 666, 999], 2, 3)  === 4);

// 'wrong4' - проверяет кейс нахождения элемента по последнему индексу
// wrong4: (items, value) => _.lastIndexOf(items, value),
assert(indexOf([1, 8, 9, 3, 9, 43], 43) === 5);
```

## Jest библиотека
https://ru.hexlet.io/courses/js-testing/lessons/jest/theory_unit 

### Установка

```bash
# установка пакета
npm init

# В директории с проектом
npm i --save-dev jest

# "type": "module" -- add in package.json

# Создание файла в каталоге проекта 
./__tests__/index.test.js
```

## Запуск теста  Jest
```bash
# запуск теста с помощью jest
# Jest поддерживает ECMAScript модули в экспериментальном режиме
# Чтобы активировать поддержку модулей в тестах,
# нужно запускать тесты с переменной окружения NODE_OPTIONS

NODE_OPTIONS=--experimental-vm-modules npx jest
```
### Usage

Для тестов Jest предоставляет две глобальные функции: test и expect. Они доступны без какого-либо импорта, так как Jest делает их глобальными функциями.

Функция **test** нужна для описания конкретного теста и его проверок. Самих тестовых функций может быть любое количество. Первым параметром эта функция принимает произвольную строчку, которая должна описывать сам тест. Эта строчка потом отображается на экране во время запуска тестов для упрощения отладки.

Второй параметр — функция, внутри которой описан проверочный код. Обратите внимание на то, что этот код не выполняется сразу. Функция test добавляет его внутрь Jest, который уже решает, как и когда запускать тесты. Это позволяет проводить различные оптимизации, например, выполнять тесты параллельно.

Jest использует "матчеры" (matchers). Это утверждения, имеющие особую структуру, напоминающую обращение к объекту. Общий принцип работы матчеров такой:

Вызывается функция **expect()**, куда передаётся актуальное (фактическое) значение.
На результате, возвращаемом функцией expect(), вызывается подходящий матчер, например, toEqual.

```js
test('reverse', () => {
  expect(reverse('hello')).toEqual('olleh');
  expect(reverse('')).toEqual('');
});

// Ожидается, что результат выражения reverse('hello') равен 'olleh'
expect(reverse('hello')).toEqual('olleh');
```
Примеры решения задач

```js
// функции проверки
  wrong1: (coll = [], ...values) => {
    const [result] = coll.reduce(([prevColl, vals], item) => {
      const newVals = vals.filter((val) => val !== item);
      const nextColl = newVals.length === vals.length ? [...prevColl, item] : prevColl;
      return [nextColl, newVals];
    }, [[], values]);

    return result;
  },

  wrong2: (coll = [], ...values) => {
    const result = coll.filter((val) => !values.includes(val));
    return result.length === 0 ? null : result;
  },


// решение
test('without', () => {
  expect(without([2, 1, 2, 3], 1, 2)).toEqual([3]);
  expect(without([2, 1, 2, 3, 4, 5], 1, 2)).toEqual([3, 4, 5]);
  expect(without([2, 1, 2, 3], 1, 2, 3)).toEqual([]);
  expect(without([2, 1, 2, 3], 41)).toEqual([2, 1, 2, 3]);
  expect(without([], 1, 2, 3)).toEqual([]);
});
```

## Матчеры (Expectations)

Любой матчер в Jest начинается с функции expect(data), в которую передаются данные на проверку. 

Затем expect возвращает специальный объект, у которого уже можно вызывать различные матчеры для проверки. 

В Jest десятки матчеров для самых разнообразных ситуаций. Такое количество объясняется желанием выдавать максимально точный отчёт о том, что произошло.

```js
const data = [1, 2, 3];
// take берет первые n элементов
// assert.equal(take(data, 2).length, 2)
expect(take(data, 1).length).toBe(2);

//
expect(null).toBeNull();

// Проверяет значение на truthy (любое значение, которое приводится к true)
expect(true).toBeTruthy();
// Точное сравнение с true
expect(true).toBe(true);

expect(undefined).toBeUndefined();

// Проверка, что массив содержит элемент
expect([1, 2, 3]).toContain(2);

// Проверка, что строка содержит подстроку
expect('hello, world').toMatch('hello');

// Проверяет, что в объекте есть свойство с определённым значением
expect({ key: 'value' }).toHaveProperty('key', 'value');

//Кроме того, к любому матчеру можно применить модификатор not, который инвертирует поведение матчера:

expect(null).not.toBeNull(); // not null
expect(undefined).not.toBeUndefined(); // not undefined
expect([1, 2, 3]).not.toContain(2); // not contain 2
expect('hello, world').not.toMatch('hello'); // not match hello


//Особняком стоит матчер toMatchObject. Он используется, когда нас в тестах интересует не весь объект, а только какая-то его часть:

const user = {
  firstName: 'tolya',
  lastName: 'petrov',
  age: '33',
};

// Тест пройдёт успешно, так как проверяется только firstName
expect(user).toMatchObject({ firstName: 'tolya' });

```

Это далеко не все матчеры, которые есть в Jest. Более того, Jest достаточно гибкий и может расширяться собственными матчерами. На Гитхабе можно найти библиотеки с матчерами для разных ситуаций.

В целом, вам придётся постоянно заглядывать в документацию, чтобы вспомнить, что там есть. Иначе всё может свестись к использованию toEqual. Пожалуй, это основной недостаток использования матчеров — необходимость помнить про них и правильно применять.

https://jestjs.io/ru/docs/expect

examples:
```js
const functions = {
  right: _.gt,
  wrong1: _.gte,
  wrong2: (a, b) => a !== b,
  wrong3: () => false,
};

//// решение
test('gt', () => {
  expect(gt(3, 1)).toEqual(true);
  expect(gt(3, 4)).toEqual(false);
  expect(gt(1, 1)).toEqual(false);
  expect(gt()).toEqual(false);
});
```


## Модульное тестирование

Это тестирование направлено на проверку модулей программы в изоляции от всех остальных частей. Эти тесты обычно тестируют базовые конструкции языка: функции, модули, классы. Такие тесты не дают никаких гарантий работы всего приложения в целом, но хорошо помогают тогда, когда какой-то модуль программы имеет сложную логику.

## Нужно ли пытаться найти все варианты? 

Не нужно. Тесты не даются бесплатно, каждая написанная строчка кода в проекте — потенциальное место для изменения в случае правок. Если есть сомнения, нужно ли писать проверку или нет, то лучше не пишите. Так вы поймёте тот минимум, который стоит писать, и после которого тесты писать не эффективно. Редкие ситуации требуют покрытия тестами только тогда, когда они критичны для работоспособности.

```js

// example
test('validator', () => {
  const validator = makeValidator();

  expect(validator.isValid('value')).toBe(true);

  validator.addCheck((v) => v > 10);
  expect(validator.isValid(100)).toEqual(true);
  expect(validator.isValid(5)).toEqual(false);
  expect(validator.isValid()).toEqual(false);

  validator.addCheck((v) => v % 2 === 0);
  expect(validator.isValid(11)).toBe(false);
  expect(validator.isValid(12)).toBe(true);
  expect(validator.isValid(8)).toBe(false);

  validator.addCheck(_.isNumber);
  expect(validator.isValid('string')).toBe(false);

});


// ToDo: определить, что проверяет эта функция? тема "модульные тесты"
export default () => ({
  checks: [],

  addCheck(fn) {
    this.checks = [fn];
  },

  isValid(data) {
    return this.checks.every((fn) => fn(data));
  },
});


//3
export default () => ({
  checks: [],

  addCheck(fn) {
    this.checks.push(fn);
  },

  isValid() {
    return true;
  },
});

```

В тестируемой функции можно создавать объект класса, а не только передавать функцию

- Внутри создавать экземпляр
- Внутри также назначать функции проверки

(!) **Тесты в скрипте "наслаиваются" друг на друга, т е они не должны противоречить друг другу** Т к тесты применяются к одним и тем же входным значениям

## Подготовка данных и устранение дублирования вводных для тестирования

Куда помещать вводные для тестирования функции?

- Внутри модуля в виде переменной?
- В отдельный модуль? 

Иметь в виду (!)
излишнее обобщение, приводящее к полному устранению дублирования, вводит неявные зависимости в код. Изменение этой коллекции почти наверняка приведёт к поломке большинства тестов, которые завязаны на её структуру, на количество элементов и их значения.

Главный вывод из этого: устранять дублирование надо. Но важно не перейти границу, после которой обобщение начинает больше мешать, чем помогать.

Модуль загружается в память ровно один раз. Это значит, что весь код, определённый на уровне модуля (включая константы), выполняется ровно один раз

Важно не забыть: функция test не запускает тест на выполнение. Она добавляет его внутрь Jest, а вот он уже решает, когда выполнить этот тест. Поэтому между загрузкой модуля и отработкой тестов проходит неопределённое время.

Для решения этой проблемы тестовые фреймворки предоставляют **хуки** — специальные функции, которые запускаются до или после тестов

```js
let now;

// Запускается перед каждым тестом
beforeEach(() => {
  now = Date.now(); // текущий timestamp
});

test('first example', () => console.log(now));
test('second example', () => console.log(now));

//  console.log __tests__/index.test.js:9
//    1583871515943
//
//  console.log __tests__/index.test.js:10
//    1583871515950


//
// Запускается один раз перед всеми тестами
beforeAll(() => {
  console.log('Поехали!', Date.now());
});

// Запускается перед каждым тестом
beforeEach(() => {
  now = Date.now(); // текущий timestamp
});

// Запускается один раз после всех тестов
afterAll(() => {
  console.log('Приехали...', Date.now());
});

```

beforeEach(callback) принимает на вход функцию, внутри которой выполняется инициализирующее действие. Оно не обязательно приводит к созданию переменных. Возможно, инициализация заключается в подготовке файловой системы, например, создании файлов.

Но если она должна создать данные и сделать их доступными в тестах, то придётся использовать переменные, определённые на уровне модуля. Так как всё, что определяется внутри функций (колбека в нашем случае), остаётся внутри этой функции.

Даже если нам нужно выполнить код один раз перед всеми тестами, его все равно нужно выполнять не на уровне модуля, а внутри хука beforeAll(callback). Этот хук запускается ровно один раз перед всеми тестами, расположенными в одном модуле.

Определение таких хуков в начале модуля (!). Далее хуки запускаются "сами" согласно их определению вверху. То есть прописывать каждый вызов хука далее по модулю не требуется.

В последнем примере ниже:

- перед каждым вызовом теста переиспользуется объект с данными через вызов копирования объекта
- тесты также разделены по целям проверки (не сведены в один большой вызов теста)
- строковые называния в вызове теста названя для обозначения цели теста (т е они не равны 1=1 функциям, которые используются в коде)

```js
// examples

// funcs
const functions = {
  right1: _.set,

  wrong1: (obj, path, value) => {
    _.set(obj, path, value);
    obj.key = 'value';
    return obj;
  },

  wrong2: (obj, path, value) => {
    obj[path] = value;
    return obj;
  },

  wrong3: (obj, path, value) => {
    if (_.get(obj, path) !== undefined) {
      _.set(obj, path, value);
    }
    return obj;
  },

};

test('set', () => {
  const object = { a: [{ b: { c: 3, d: 666, e: 0 } }] };

  set(object, 'a[0].b.c', 4);
  expect(object.a[0].b.c).toEqual(4);
  expect(object).toEqual({ a: [{ b: { c: 4, d: 666, e: 0 } }] });

  // проверяет работу функции в ситуации, когда передается ключ, 
  // которого нет в объекте (ожидаемое поведение - создать значение)
  set(object, 'a[1]]', 42);
  expect(object).toEqual({ a: [{ b: { c: 4, d: 666, e: 0 } }, 42] });
});

// Пример
// BEGIN
let data;
let dataCopy;

beforeEach(() => {
  data = {
    a: [
      {
        b: {
          c: 3,
        },
      },
    ],
  };
  dataCopy = _.cloneDeep(data);
});

test('plain set', () => {
  set(data, 'a', 'value');
  dataCopy.a = 'value';
  expect(data).toEqual(dataCopy);
});

test('nested set', () => {
  set(data, 'a[0].b.c', true);
  dataCopy.a[0].b.c = true;
  expect(data).toEqual(dataCopy);
});

test('set new property', () => {
  set(data, 'a[0].b.d', false);
  dataCopy.a[0].b.d = false;
  expect(data).toEqual(dataCopy);
});
// END
```

## Практики тестирования - лучшие и плохие

Одно из ключевых правил: тесты не должны влиять друг на друга. Это значит, что любой тест выполняется так, как будто других тестов не существует в природе.

### Взаимное влияние тестов

Нарушить это правило очень просто. Один тест может создать файл, изменить переменную или записать что-то в базу. Если остальные тесты наткнутся на эти изменения, то они могут упасть там, где не должны падать, или наоборот — успешно пройти там, где не должны проходить. Кроме этого, в такой ситуации вводится неопределённость. Такие тесты могут падать эпизодически без видимых на то причин. Например, когда тест запускают изолированно, то он работает, а когда вместе с остальными — падает

### Условные конструкции в тесте

Любое ветвление внутри тестов это фактически несколько тестов в рамках одного теста. От этого надо избавляться и никогда так не писать.

### Тест вне тестов

Задача beforeEach — готовить данные и среду для тестирования, а задача test — вызывать код, который тестируется, и проводить проверки.

### Слишком сильная детализация

Вместо одного теста, в котором содержатся все необходимые проверки, программист создаёт 5 тестов, в каждом из которых ровно одна проверка. Единственным результатом такого разделения будет большее количество кода и усложнение рефакторинга в будущем, когда кода станет по-настоящему много

### Глубокая вложенность

Jest позволяет группировать тесты в блоки describe.
Они помогают структурировать сложные тесты и задать для каждого блока describe свой собственный beforeEach. Хотя такая возможность бывает полезна, но очень легко начать использовать её во вред. Глубокая иерархия тестов очень тяжело поддаётся анализу и фиксирует структуру. Из-за этого возникают сложности при добавлении новых проверок. Становится непонятно, к чему она относится

```js
describe('User', () => {
  test('should be valid', () => { /* ... */ });
});

describe('', () => {
  describe('...', () => {
    describe('...', () => {
      test('should be valid', () => { /* ... */ })
    });
  });
});

```

### Код с тестами писать дольше, чем код без тестов

Это очень интересный вопрос, по которому можно понять, насколько хорошо программист умеет писать тесты. Несмотря на то, что некоторые виды тестирования действительно сложны и требуют дополнительного времени, ежедневные тесты, которые пишутся вместе с кодом, должны приводить к ускорению разработки. И на это есть пять причин:

1) Тесты влияют на дизайн кода. Они помогают выявить неудачные решения намного раньше.
2) Подготовка входных данных может занимать значительное время. С тестами это нужно сделать один раз.
3) Проверка результата работы кода может быть сложной и разнообразной. Тесты позволяют об этом не думать, они сами проверяют, что всё хорошо, включая пограничные случаи.
4) Если в проекте тесты пишутся регулярно, то проще и быстрее делать рефакторинг, так как не придётся проверять вручную другие части кода.
5) Тесты снижают уровень стресса.

```js
// examples

test('cart', () => {
  const cart = makeCart();
  expect(cart.getItems()).toHaveLength(0); //

  cart.addItem({ name: 'car', price: 3 }, 5);
  cart.addItem({ name: 'house', price: 10 }, 2);

  expect(cart.getItems().length).toEqual(2);
  expect(cart.getCount()).toEqual(7);
  expect(cart.getCost()).toEqual(35);

  cart.addItem({ name: 'house', price: 10 }, 1);
  expect(cart.getItems().length).toEqual(3);
  expect(cart.getCost()).toEqual(45);

// new 
  const car = { name: 'car', price: 3 };
  cart.addItem(car, 5);
  expect(cart.getItems()).toEqual(expect.arrayContaining([{ good: car, count: 5 }]));
});

// begin
test('Cart', () => {
  const cart = makeCart();
  expect(cart.getItems()).toHaveLength(0);

  const car = { name: 'car', price: 3 };
  cart.addItem(car, 5);
  expect(cart.getItems()).toEqual(expect.arrayContaining([{ good: car, count: 5 }]));
  expect(cart.getCost()).toBe(15);
  expect(cart.getCount()).toBe(5);

  const house = { name: 'house', price: 10 };
  cart.addItem(house, 2);
  expect(cart.getItems()).toEqual(
    expect.arrayContaining([{ good: car, count: 5 }, { good: house, count: 2 }],
  ));
  expect(cart.getCost()).toBe(35);
  expect(cart.getCount()).toBe(7);
});
// end

```
Пример упражнения:
```js
// BEGIN (write your solution here)

test('fillMiddle', () => {
  const array = [1, 2, 3, 4]; 
  fill(array, '*', 1, 3);
  expect(array).toEqual([1, '*', '*', 4]);
});

test('fillAll', () => {
  const array = [1, 2, 3, 4]; 
  fill(array, '*');
  expect(array).toEqual(['*', '*', '*', '*']);
});

test('fillStartGreaterThanEnd', () => {
  const array = [1, 2, 3, 4]; 
  fill(array, '*', 4);
  expect(array).toEqual([1, 2, 3, 4]);
});

test('fillInAndOut', () => {
  const array = [1, 2, 3, 4]; 
  fill(array, '*', 0, 10);
  expect(array).toEqual(['*', '*', '*', '*']);
});

// END

// ternar condition for variable
const normalizedStart = start > collLength ? end : start;
const normalizedEnd = end > collLength ? collLength : end;
```

## Покрытие кода тестами (Code coverage)

Протестированность кода можно измерить. Для этого используют метрику "покрытие кода тестами" (code coverage). Покрытие анализируется тестовыми фреймворками, которые считают отношения строчек, задействованных в тестах, ко всем строчкам исходного кода.

Например, если в коде есть условная конструкция, и она не проверяется тестами, это значит, что все строки кода, входящие в неё, не будут покрыты.

В Jest покрытие измеряется крайне просто. Достаточно запустить тесты с флагом --coverage:

```bash
npx jest --coverage
```

После выполнения всех тестов, Jest выводит сводную таблицу по каждому файлу. В ней показан процент покрытия кода тестами. В примере выше видно что в файле index.js покрыто 100% кода, а вот в файле half.js только 60%. При этом общее покрытие кода 71.43%. Обратите внимание, что покрытие сильно зависит от того, какие тесты выполнились. Если часть из них упала с ошибками, то Jest покажет намного меньшее покрытие, так как тесты просто не доберутся до всего кода. Поэтому покрытие меряют только тогда, когда все тесты зелёные.

Эта статистика помогает найти места, где тестов мало. Дальше по ситуации их можно начинать добавлять. Если в проекте тестов не было вообще, то эта статистика начинает быстро расти. А вот дальше, ближе к 90 процентам, придётся бороться за каждую строчку кода.

Однако покрытие само по себе не гарантирует, что покрытый код работает правильно во всех ситуациях. Логические ошибки в коде невозможно отследить только покрытием. Для этого нужны тесты на одну и ту же функциональность, но с разным набором данных. Как правило, это тесты на пограничные случаи. В разработке есть хорошая практика: перед тем как чинить баги, сначала нужно написать тесты, которые их воспроизводят, и только затем уже можно починить их.

Какое покрытие считается допустимым? 100% покрытия выглядит красиво, но добиться его невероятно сложно. И для большинства проектов бессмысленно. Затраченные усилия не окупятся. Большинство разработчиков сходится во мнении, что 80% — это достаточно хорошее покрытие. На этом можно и остановиться.

## TDD - Разработка через тестирование

В какой момент лучше писать тесты? Вообще, существует три подхода:

- Тесты пишутся после кода
- Тесты пишутся вместе с кодом
- Тесты пишутся до кода

В тестах более низкого уровня, интеграционных и модульных тестах, обычно можно выбирать из вариантов описанных выше. И подход "писать тесты после кода" относится к наименее полезным. Почему?

Сам процесс написания кода связан с постоянным запуском кода и проверкой того, что он работает. 

В реальном коде подготовка данных для проверки работы кода может занимать значительное время, минуты и десятки минут. С другой стороны, результатом работы проверяемого кода может быть что-то сложное, например, множество записей в базе данных или вывод определённой непростой структуры. Тогда каждый запуск кода на проверку превращается в целое приключение.

У тестирования до написания кода есть ещё одно мощное преимущество. Оно заставляет программиста в первую очередь думать о дизайне своего решения, о том, как им будут пользоваться. А не о том, как красиво он реализует всё внутри. Грамотные интерфейсы – залог успеха.

В мире разработки подход, при котором тесты пишутся до кода, называется Test-Driven Development (TDD).

```js
// тест
test('repeat', () => {
  expect(repeat('$', 3)).toBe('$$$');
});

// вызов
repeat('$', 3); // $$$

```

TDD по задумке изобретателя этой техники подразумевает, что вся разработка состоит из повторяющегося цикла, где на каждой итерации пишется тест, который не проходит, затем дописывается код, удовлетворяющий данному тесту. После этого всё повторяется. Так, шаг за шагом, строится приложение.

Сейчас все по инерции продолжают говорить именно о таком способе. В нём тесты пишутся на все части кода с максимальной детализацией. Этот вид TDD хоть и говорит о важности дизайна, но фокусируется на конкретных функциях и классах приложения вместо цельной картины. Но есть и другое TDD, где тесты на внутренние части не пишутся почти никогда.

## CI - continuos integration. Непрерывная интеграция

https://ru.hexlet.io/courses/js-testing/lessons/ci/theory_unit


Непрерывная интеграция – практика разработки, которая заключается в частой автоматизированной сборке приложения для быстрого выявления проблем.

Обычно интеграция выполняется на коммиты в репозиторий. За этим следит либо специальный сервер, либо сервис непрерывной интеграции. Он загружает код, собирает его (если это нужно для текущего приложения) и запускает различные проверки. Что и как запускать – определяется программистом. В первую очередь это тесты и линтер (проверка оформления кода). Кроме них могут запускаться утилиты, анализирующие безопасность, актуальность зависимостей и многое другое.


На каждый коммит запускается сборка (build). Во время сборки собирается приложение, устанавливаются зависимости, прогоняются тесты и все остальные проверки. Сборка, завершившаяся без ошибок, считается успешной. Если сборка не проходит, то программист получает уведомление.


GitHub Actions — бесплатная система, которая позволяет автоматизировать какие-либо действия, важные для процесса разработки. Она обеспечивает непрерывную интеграцию (но может гораздо больше)

- Воркфлоу / Workflows

  Каждый репозиторий на GitHub может содержать один или несколько воркфлоу. Каждый воркфлоу определяется в отдельном файле конфигурации в каталоге репозитория .github/workflows. Несколько воркфлоу могут выполняться параллельно.

- События / Events

  Воркфлоу может запускаться одним или несколькими событиями. Это могут быть внутренние события GitHub (например, пуш, релиз или пул-реквест), запланированные события (запускаются в определенное время — например, cron), или произвольными внешними событиями (запускаются вызовом Webhook API GitHub).

- Задания / Jobs

  Воркфлоу состоит из одного или нескольких заданий. Задание содержит набор команд, которые запускаются вместе с рабочим процессом. По умолчанию при запуске воркфлоу все его задания выполняются параллельно, однако между ними можно определить зависимость, чтобы они выполнялись последовательно.

- Раннеры / Runners

  Каждое задание выполняется на определённом раннере, — временном сервере на GitHub с выбранной операционной системой (Linux, macOS или Windows). Также существуют автономные раннеры, которые позволяют создать своё окружение для выполнения экшена.

- Шаги / Steps

  Задания состоят из последовательности шагов. Шаг — это либо команда оболочки (shell command), либо экшен (action). Все шаги задания выполняются последовательно на раннере, связанном с заданием. По умолчанию в случае сбоя шага все следующие шаги задания пропускаются.

- Экшен / Actions

  Экшен — многократно используемый блок кода, который может служить шагом задания. Каждый экшен может принимать на вход параметры и создавать любые значения, которые затем можно использовать в других экшенах. Разработчики могут создавать собственные экшены или использовать опубликованные сообществом GitHub


### Пример воркфлоу. Hello, World!
Этот воркфлоу не делает ничего особенного — он просто показывает фразу Hello, World! в стандартном выводе runner всякий раз, когда происходит отправка кода в репозиторий. Вот как выглядит код этого воркфлоу

```yaml
name: hello-world
on: push
jobs:
  my-job:
    runs-on: ubuntu-latest
    steps:
      - name: my-step
        run: echo "Hello World!"
```

Разберём его в деталях:

- Имя воркфлоу hello-world, определяется полем name.
- Воркфлоу запускается событием push, которое определяет поле on.
- Воркфлоу содержит одно задание с идентификатором my-job в нём указано имя задания.
- В задании my-job используется runner ubuntu-latest из GitHub Marketplace — он определяется полем runs-on.
- Задание my-job содержит один шаг с именем my-step. На этом шаге выполняется команда оболочки echo — в нашем случае это "Hello World!".
